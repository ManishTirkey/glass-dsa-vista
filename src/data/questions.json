
[
  {
    "id": "1",
    "title": "Two Sum",
    "difficulty": "Easy",
    "topics": ["Arrays", "Hash Table"],
    "shortDescription": "Find two numbers in an array that add up to a target value.",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1,2]",
        "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
      }
    ],
    "approaches": [
      {
        "name": "Brute Force",
        "description": "Check all possible pairs of numbers in the array to see if they add up to the target.",
        "solution": "vector<int> twoSum(vector<int>& nums, int target) {\n    for (int i = 0; i < nums.size(); i++) {\n        for (int j = i + 1; j < nums.size(); j++) {\n            if (nums[i] + nums[j] == target) {\n                return {i, j};\n            }\n        }\n    }\n    return {}; // No solution found\n}",
        "complexity": {
          "time": "O(nÂ²) where n is the length of the array.",
          "space": "O(1), constant space."
        }
      },
      {
        "name": "Hash Map (One Pass)",
        "description": "Use a hash map to store previously seen values and their indices. For each number, check if the complement exists in the map.",
        "solution": "vector<int> twoSum(vector<int>& nums, int target) {\n    unordered_map<int, int> seen;\n    \n    for (int i = 0; i < nums.size(); i++) {\n        int complement = target - nums[i];\n        \n        if (seen.find(complement) != seen.end()) {\n            return {seen[complement], i};\n        }\n        \n        seen[nums[i]] = i;\n    }\n    \n    return {}; // No solution found\n}",
        "complexity": {
          "time": "O(n) where n is the length of the array.",
          "space": "O(n) for the hash map."
        }
      }
    ],
    "completed": true,
    "answer": {
      "code": "/**\n * @param vector<int>& nums\n * @param int target\n * @return vector<int>\n */\nvector<int> twoSum(vector<int>& nums, int target) {\n    // Create a hash map to store values we've seen and their indices\n    unordered_map<int, int> seen;\n    \n    // Iterate through the array once\n    for (int i = 0; i < nums.size(); i++) {\n        // Calculate what number we need to find\n        int complement = target - nums[i];\n        \n        // If we've seen the complement before, we found our answer\n        if (seen.find(complement) != seen.end()) {\n            return {seen[complement], i};\n        }\n        \n        // Otherwise, store the current number and its index\n        seen[nums[i]] = i;\n    }\n    \n    // If no solution is found (problem states there will always be one)\n    return {};\n}",
      "explanation": "My approach uses a hash map to store numbers as we iterate through the array. For each number, we calculate what other number (complement) would be needed to reach the target sum.\n\nIf we've already seen that complement in our previous iterations, we have our answer! If not, we add the current number to our hash map and continue.\n\nThis is an efficient O(n) time complexity solution because hash map lookups are O(1), and we only need to go through the array once. The space complexity is O(n) in the worst case where we might need to store most elements in the hash map before finding a match."
    }
  },
  {
    "id": "2",
    "title": "Valid Parentheses",
    "difficulty": "Easy",
    "topics": ["Stack", "String"],
    "shortDescription": "Determine if a string of brackets is valid.",
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets, and Open brackets must be closed in the correct order.",
    "examples": [
      {
        "input": "s = \"()\"",
        "output": "true"
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true"
      },
      {
        "input": "s = \"(]\"",
        "output": "false"
      }
    ],
    "approaches": [
      {
        "name": "Stack",
        "description": "Use a stack to keep track of opening brackets and ensure they match with the closing ones.",
        "solution": "bool isValid(string s) {\n    stack<char> st;\n    unordered_map<char, char> pairs = {\n        {'(', ')'},\n        {'[', ']'},\n        {'{', '}'}\n    };\n    \n    for (char c : s) {\n        if (pairs.find(c) != pairs.end()) {\n            // If it's an opening bracket, push to stack\n            st.push(c);\n        } else {\n            // If it's a closing bracket\n            if (st.empty() || pairs[st.top()] != c) {\n                return false;\n            }\n            st.pop();\n        }\n    }\n    \n    // If the stack is empty, all brackets were matched properly\n    return st.empty();\n}",
        "complexity": {
          "time": "O(n) where n is the length of the string.",
          "space": "O(n) in worst case for the stack."
        }
      }
    ],
    "completed": false,
    "answer": {
      "code": "/**\n * @param string s\n * @return bool\n */\nbool isValid(string s) {\n    // Edge case: empty string is considered valid\n    if (s.empty()) return true;\n    \n    // Edge case: odd length strings can't be valid as brackets come in pairs\n    if (s.length() % 2 != 0) return false;\n    \n    // Map opening brackets to their corresponding closing brackets\n    unordered_map<char, char> bracketPairs = {\n        {'(', ')'},\n        {'[', ']'},\n        {'{', '}'}\n    };\n    \n    stack<char> st;\n    \n    for (char c : s) {\n        // If it's an opening bracket, push to stack\n        if (bracketPairs.find(c) != bracketPairs.end()) {\n            st.push(c);\n        } else {\n            // If it's a closing bracket\n            // First check if stack is empty (no matching opening bracket)\n            if (st.empty()) return false;\n            \n            // Get the last opening bracket\n            char lastBracket = st.top();\n            st.pop();\n            \n            // Check if the closing bracket matches the last opening bracket\n            if (bracketPairs[lastBracket] != c) return false;\n        }\n    }\n    \n    // Valid only if all brackets were matched (stack is empty)\n    return st.empty();\n}",
      "explanation": "To solve this problem, I used a stack data structure which is perfect for tracking the most recent opening brackets. The algorithm works by iterating through each character in the string.\n\nIf we encounter an opening bracket ('(', '[', or '{'), we push it onto our stack. If we encounter a closing bracket (')', ']', or '}'), we check if it matches the most recently seen opening bracket by popping the stack. If it doesn't match or if the stack is empty when we see a closing bracket, we know the string is invalid.\n\nAfter processing the entire string, we also need to make sure the stack is empty. If there are any remaining opening brackets without matching closing brackets, the string is invalid.\n\nThe solution is efficient with O(n) time complexity where n is the length of the string, and O(n) space complexity for the stack in the worst case."
    }
  },
  {
    "id": "3",
    "title": "Maximum Subarray",
    "difficulty": "Medium",
    "topics": ["Array", "Divide and Conquer", "Dynamic Programming"],
    "shortDescription": "Find the contiguous subarray with the largest sum.",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
      },
      {
        "input": "nums = [1]",
        "output": "1"
      }
    ],
    "approaches": [
      {
        "name": "Kadane's Algorithm",
        "description": "Use dynamic programming to keep track of the maximum sum ending at each position.",
        "solution": "int maxSubArray(vector<int>& nums) {\n    int currentSum = nums[0];\n    int maxSum = nums[0];\n    \n    for (int i = 1; i < nums.size(); i++) {\n        currentSum = max(nums[i], currentSum + nums[i]);\n        maxSum = max(maxSum, currentSum);\n    }\n    \n    return maxSum;\n}",
        "complexity": {
          "time": "O(n) where n is the length of the array.",
          "space": "O(1), constant space."
        }
      }
    ],
    "completed": false,
    "answer": {
      "code": "/**\n * @param vector<int>& nums\n * @return int\n */\nint maxSubArray(vector<int>& nums) {\n    // Handle edge case of empty array\n    if (nums.empty()) return 0;\n    \n    // Initialize our variables with the first element\n    int currentSum = nums[0];\n    int maxSum = nums[0];\n    \n    // Start from the second element (if it exists)\n    for (int i = 1; i < nums.size(); i++) {\n        // For each element, we have two choices:\n        // 1. Add it to our current subarray\n        // 2. Start a new subarray beginning with this element\n        // We choose whichever gives a larger sum\n        currentSum = max(nums[i], currentSum + nums[i]);\n        \n        // Update the maximum sum we've seen so far\n        maxSum = max(maxSum, currentSum);\n    }\n    \n    return maxSum;\n}",
      "explanation": "I approached this problem using Kadane's algorithm, which is an elegant dynamic programming solution. The core insight is that at each position, we have two options: either start a new subarray at the current position, or extend the existing subarray by including the current element.\n\nFor each element in the array, we calculate the maximum subarray sum ending at that position by taking the maximum of:\n1. The current element by itself (starting a new subarray)\n2. The previous maximum subarray sum plus the current element (extending the existing subarray)\n\nWe keep track of the global maximum sum we've seen so far. This approach is optimal because it only requires a single pass through the array and uses constant extra space.\n\nTime complexity: O(n) where n is the length of the array\nSpace complexity: O(1) as we only need two variables regardless of input size"
    }
  },
  {
    "id": "4",
    "title": "Merge Two Sorted Lists",
    "difficulty": "Easy",
    "topics": ["Linked List", "Recursion"],
    "shortDescription": "Merge two sorted linked lists into one sorted list.",
    "description": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.",
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]"
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]"
      }
    ],
    "approaches": [
      {
        "name": "Iterative",
        "description": "Create a dummy head and iterate through both lists, choosing the smaller value to add to the result.",
        "solution": "ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n    ListNode dummy(-1);\n    ListNode* current = &dummy;\n    \n    while (l1 && l2) {\n        if (l1->val < l2->val) {\n            current->next = l1;\n            l1 = l1->next;\n        } else {\n            current->next = l2;\n            l2 = l2->next;\n        }\n        current = current->next;\n    }\n    \n    // Attach remaining nodes from either list\n    current->next = l1 ? l1 : l2;\n    \n    return dummy.next;\n}",
        "complexity": {
          "time": "O(n+m) where n and m are the lengths of the two lists.",
          "space": "O(1) because we only use a constant amount of extra space."
        }
      },
      {
        "name": "Recursive",
        "description": "Use recursion to determine which list node to take and construct the merged list.",
        "solution": "ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n    if (!l1) return l2;\n    if (!l2) return l1;\n    \n    if (l1->val < l2->val) {\n        l1->next = mergeTwoLists(l1->next, l2);\n        return l1;\n    } else {\n        l2->next = mergeTwoLists(l1, l2->next);\n        return l2;\n    }\n}",
        "complexity": {
          "time": "O(n+m) where n and m are the lengths of the two lists.",
          "space": "O(n+m) for the recursion stack in worst case."
        }
      }
    ],
    "completed": false,
    "answer": {
      "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * @param ListNode* list1\n * @param ListNode* list2\n * @return ListNode*\n */\nListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n    // Create a dummy head to simplify edge cases\n    ListNode dummy(-1);\n    ListNode* current = &dummy;\n    \n    // Traverse both lists and compare nodes\n    while (list1 != nullptr && list2 != nullptr) {\n        // Choose the node with the smaller value\n        if (list1->val <= list2->val) {\n            current->next = list1;\n            list1 = list1->next;\n        } else {\n            current->next = list2;\n            list2 = list2->next;\n        }\n        \n        // Move the pointer forward\n        current = current->next;\n    }\n    \n    // If one list is longer than the other, append the remaining nodes\n    current->next = list1 == nullptr ? list2 : list1;\n    \n    // Return the head of the merged list (skip dummy node)\n    return dummy.next;\n}",
      "explanation": "I approached this problem using an iterative solution with a dummy head to simplify edge cases. The key insight is that we can build the merged list by comparing the current nodes of both lists and always choosing the smaller value.\n\nThe algorithm works by:\n1. Creating a dummy node to serve as the starting point of our result list\n2. Maintaining a current pointer that tracks where we should add the next node\n3. Comparing the values of the current nodes in both input lists\n4. Attaching the node with the smaller value to our result list\n5. Advancing the pointer in the list that contributed the node\n6. After one list is exhausted, attaching the remainder of the other list\n\nThis approach is efficient with O(n+m) time complexity where n and m are the lengths of the input lists. The space complexity is O(1) since we're reusing the nodes from the input lists rather than creating new ones."
    }
  },
  {
    "id": "5",
    "title": "Best Time to Buy and Sell Stock",
    "difficulty": "Easy",
    "topics": ["Array", "Dynamic Programming"],
    "shortDescription": "Find the maximum profit from buying and selling a stock once.",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
      }
    ],
    "approaches": [
      {
        "name": "One Pass",
        "description": "Keep track of the minimum price seen so far and calculate the maximum profit that can be achieved.",
        "solution": "int maxProfit(vector<int>& prices) {\n    int minPrice = INT_MAX;\n    int maxProfit = 0;\n    \n    for (int i = 0; i < prices.size(); i++) {\n        if (prices[i] < minPrice) {\n            minPrice = prices[i];\n        } else if (prices[i] - minPrice > maxProfit) {\n            maxProfit = prices[i] - minPrice;\n        }\n    }\n    \n    return maxProfit;\n}",
        "complexity": {
          "time": "O(n) where n is the number of prices.",
          "space": "O(1), constant space."
        }
      }
    ],
    "completed": false,
    "answer": {
      "code": "/**\n * @param vector<int>& prices\n * @return int\n */\nint maxProfit(vector<int>& prices) {\n    // Edge case: empty array or single price\n    if (prices.size() <= 1) return 0;\n    \n    int minPrice = prices[0];\n    int maxProfit = 0;\n    \n    for (int i = 1; i < prices.size(); i++) {\n        // If current price is lower than min price seen so far, update min price\n        // This represents a better day to buy\n        if (prices[i] < minPrice) {\n            minPrice = prices[i];\n        } \n        // If selling at today's price would give better profit, update max profit\n        else if (prices[i] - minPrice > maxProfit) {\n            maxProfit = prices[i] - minPrice;\n        }\n    }\n    \n    return maxProfit;\n}",
      "explanation": "I tackled this problem with a single-pass approach that tracks two key variables: the minimum stock price we've seen so far and the maximum profit we could make.\n\nThe insight is that to maximize profit, we want to buy at the lowest price and sell at the highest price afterward. As we scan through the array, we continuously update:\n\n1. The minimum price we've seen so far (potential buying point)\n2. The maximum profit we can make by selling at the current price\n\nThis approach is elegant because we don't need to try all possible buy-sell combinations. At each step, we either find a better day to buy (lower price) or calculate if selling today would give us more profit than our best-known profit.\n\nThe time complexity is O(n) where n is the number of prices, as we only need to scan the array once. The space complexity is O(1) since we only use two variables regardless of input size."
    }
  },
  {
    "id": "6",
    "title": "Valid Palindrome",
    "difficulty": "Easy",
    "topics": ["String", "Two Pointers"],
    "shortDescription": "Determine if a string is a palindrome ignoring non-alphanumeric characters.",
    "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.",
    "examples": [
      {
        "input": "s = \"A man, a plan, a canal: Panama\"",
        "output": "true",
        "explanation": "\"amanaplanacanalpanama\" is a palindrome."
      }
    ],
    "approaches": [
      {
        "name": "Two Pointers",
        "description": "Use two pointers at the start and end of the string and move them towards the center, comparing characters.",
        "solution": "bool isPalindrome(string s) {\n    string clean = \"\";\n    \n    // Remove non-alphanumeric and convert to lowercase\n    for (char c : s) {\n        if (isalnum(c)) {\n            clean += tolower(c);\n        }\n    }\n    \n    int left = 0;\n    int right = clean.length() - 1;\n    \n    while (left < right) {\n        if (clean[left] != clean[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}",
        "complexity": {
          "time": "O(n) where n is the length of the string.",
          "space": "O(n) for creating the cleaned string."
        }
      }
    ],
    "completed": true,
    "answer": {
      "code": "/**\n * @param string s\n * @return bool\n */\nbool isPalindrome(string s) {\n    // Use two pointers approach for better efficiency\n    int left = 0;\n    int right = s.length() - 1;\n    \n    while (left < right) {\n        // Skip non-alphanumeric characters from left\n        while (left < right && !isalnum(s[left])) {\n            left++;\n        }\n        \n        // Skip non-alphanumeric characters from right\n        while (left < right && !isalnum(s[right])) {\n            right--;\n        }\n        \n        // Compare characters (case-insensitive)\n        if (tolower(s[left]) != tolower(s[right])) {\n            return false;\n        }\n        \n        left++;\n        right--;\n    }\n    \n    return true;\n}",
      "explanation": "I solved this problem with a more optimized two-pointer approach that avoids creating a new string. Instead of cleaning the string first, we process characters as we go.\n\nThe algorithm uses two pointers - one starting from the beginning of the string and the other from the end. We move these pointers toward each other, skipping any non-alphanumeric characters. For each valid pair of characters we encounter, we compare them after converting to lowercase.\n\nIf at any point the characters don't match, the string is not a palindrome. If the pointers meet or cross without finding any mismatches, the string is a palindrome.\n\nThis approach has O(n) time complexity where n is the length of the string, but uses O(1) extra space since we don't create a new string. This is more efficient than creating a cleaned string first, especially for long strings with many non-alphanumeric characters."
    }
  },
  {
    "id": "7",
    "title": "Invert Binary Tree",
    "difficulty": "Easy",
    "topics": ["Tree", "Depth-First Search", "Breadth-First Search", "Binary Tree"],
    "shortDescription": "Invert a binary tree (swap left and right children).",
    "description": "Given the root of a binary tree, invert the tree, and return its root. Inverting a binary tree means swapping the left and right children of all nodes.",
    "examples": [
      {
        "input": "root = [4,2,7,1,3,6,9]",
        "output": "[4,7,2,9,6,3,1]"
      }
    ],
    "approaches": [
      {
        "name": "Recursive",
        "description": "Recursively invert the left and right subtrees and swap them.",
        "solution": "TreeNode* invertTree(TreeNode* root) {\n    if (!root) return nullptr;\n    \n    TreeNode* left = invertTree(root->left);\n    TreeNode* right = invertTree(root->right);\n    \n    root->left = right;\n    root->right = left;\n    \n    return root;\n}",
        "complexity": {
          "time": "O(n) where n is the number of nodes in the tree.",
          "space": "O(h) where h is the height of the tree for the recursion stack."
        }
      },
      {
        "name": "Iterative (BFS)",
        "description": "Use a queue to perform level-order traversal and invert each node's children.",
        "solution": "TreeNode* invertTree(TreeNode* root) {\n    if (!root) return nullptr;\n    \n    queue<TreeNode*> q;\n    q.push(root);\n    \n    while (!q.empty()) {\n        TreeNode* node = q.front();\n        q.pop();\n        \n        // Swap children\n        TreeNode* temp = node->left;\n        node->left = node->right;\n        node->right = temp;\n        \n        if (node->left) q.push(node->left);\n        if (node->right) q.push(node->right);\n    }\n    \n    return root;\n}",
        "complexity": {
          "time": "O(n) where n is the number of nodes in the tree.",
          "space": "O(n) in worst case for the queue."
        }
      }
    ],
    "completed": false,
    "answer": {
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n/**\n * @param TreeNode* root\n * @return TreeNode*\n */\nTreeNode* invertTree(TreeNode* root) {\n    // Base case: if the tree is empty or we're at a leaf\n    if (root == nullptr) return nullptr;\n    \n    // Swap the children\n    TreeNode* temp = root->left;\n    root->left = root->right;\n    root->right = temp;\n    \n    // Recursively invert the subtrees\n    invertTree(root->left);\n    invertTree(root->right);\n    \n    // Return the inverted tree\n    return root;\n}",
      "explanation": "For this problem, I chose a recursive approach because the structure of binary trees naturally lends itself to recursion. The idea is elegant in its simplicity: for each node, we swap its left and right children, then recursively apply the same operation to both subtrees.\n\nThe recursive algorithm works as follows:\n1. Handle the base case: if the current node is null, return null\n2. Swap the left and right children of the current node\n3. Recursively invert the left subtree\n4. Recursively invert the right subtree\n5. Return the root of the inverted tree\n\nThis approach traverses each node exactly once, giving us a time complexity of O(n) where n is the number of nodes in the tree. The space complexity is O(h) where h is the height of the tree, due to the recursion stack. In the worst case of a skewed tree, this could be O(n), but for a balanced tree, it would be O(log n)."
    }
  },
  {
    "id": "8",
    "title": "Linked List Cycle",
    "difficulty": "Easy",
    "topics": ["Hash Table", "Linked List", "Two Pointers"],
    "shortDescription": "Determine if a linked list has a cycle.",
    "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer.",
    "examples": [
      {
        "input": "head = [3,2,0,-4], pos = 1",
        "output": "true",
        "explanation": "There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed)."
      }
    ],
    "approaches": [
      {
        "name": "Floyd's Cycle-Finding Algorithm (Tortoise and Hare)",
        "description": "Use two pointers moving at different speeds. If there's a cycle, they will eventually meet.",
        "solution": "bool hasCycle(ListNode *head) {\n    if (!head || !head->next) return false;\n    \n    ListNode *slow = head;\n    ListNode *fast = head;\n    \n    while (fast && fast->next) {\n        slow = slow->next;        // Move slow pointer by 1\n        fast = fast->next->next;   // Move fast pointer by 2\n        \n        if (slow == fast) return true;  // If they meet, there's a cycle\n    }\n    \n    return false;  // If fast reaches the end, no cycle\n}",
        "complexity": {
          "time": "O(n) where n is the number of nodes in the list.",
          "space": "O(1), constant space."
        }
      },
      {
        "name": "Hash Set",
        "description": "Store visited nodes in a hash set and check if a node has been visited before.",
        "solution": "bool hasCycle(ListNode *head) {\n    unordered_set<ListNode*> visited;\n    \n    ListNode *current = head;\n    while (current) {\n        if (visited.find(current) != visited.end()) {\n            return true;  // Found a cycle\n        }\n        \n        visited.insert(current);\n        current = current->next;\n    }\n    \n    return false;  // No cycle found\n}",
        "complexity": {
          "time": "O(n) where n is the number of nodes in the list.",
          "space": "O(n) for storing the visited nodes."
        }
      }
    ],
    "completed": false,
    "answer": {
      "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n/**\n * @param ListNode *head\n * @return bool\n */\nbool hasCycle(ListNode *head) {\n    // Edge case: empty list or single node cannot have a cycle\n    if (!head || !head->next) return false;\n    \n    // Initialize two pointers - slow moves by 1, fast moves by 2\n    ListNode *slow = head;\n    ListNode *fast = head;\n    \n    // Keep moving until fast reaches the end\n    while (fast && fast->next) {\n        // Move slow one step\n        slow = slow->next;\n        // Move fast two steps\n        fast = fast->next->next;\n        \n        // If they meet, there's a cycle\n        if (slow == fast) {\n            return true;\n        }\n    }\n    \n    // If fast pointer reached the end, there's no cycle\n    return false;\n}",
      "explanation": "I implemented Floyd's Cycle-Finding Algorithm (also known as the \"tortoise and hare\" algorithm) to detect cycles in the linked list. The beauty of this approach is that it uses only constant extra space regardless of the list size.\n\nThe algorithm works by using two pointers that move at different speeds:\n\n1. The slow pointer (tortoise) moves one node at a time\n2. The fast pointer (hare) moves two nodes at a time\n\nIf there's a cycle in the list, the fast pointer will eventually catch up to the slow pointer, and they'll meet at some point within the cycle. If there's no cycle, the fast pointer will reach the end of the list.\n\nThis approach has a time complexity of O(n), where n is the number of nodes in the list. In the worst case, the slow pointer will need to travel through the non-cyclic part of the list plus one loop around the cycle before meeting the fast pointer. The space complexity is O(1) as we only need two pointers regardless of the list size."
    }
  },
  {
    "id": "9",
    "title": "Climbing Stairs",
    "difficulty": "Easy",
    "topics": ["Math", "Dynamic Programming", "Memoization"],
    "shortDescription": "Count the ways to climb n stairs taking 1 or 2 steps at a time.",
    "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways: 1+1 and 2."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways: 1+1+1, 1+2, and 2+1."
      }
    ],
    "approaches": [
      {
        "name": "Dynamic Programming",
        "description": "Use DP to build up the solution based on the Fibonacci sequence pattern.",
        "solution": "int climbStairs(int n) {\n    if (n <= 2) return n;\n    \n    vector<int> dp(n + 1);\n    dp[1] = 1;\n    dp[2] = 2;\n    \n    for (int i = 3; i <= n; i++) {\n        dp[i] = dp[i-1] + dp[i-2];\n    }\n    \n    return dp[n];\n}",
        "complexity": {
          "time": "O(n) as we calculate each step once.",
          "space": "O(n) for the DP array."
        }
      },
      {
        "name": "Fibonacci Optimized",
        "description": "Since we only need the last two results, we can use constant space.",
        "solution": "int climbStairs(int n) {\n    if (n <= 2) return n;\n    \n    int prev1 = 1;  // Ways to climb 1 step\n    int prev2 = 2;  // Ways to climb 2 steps\n    \n    for (int i = 3; i <= n; i++) {\n        int current = prev1 + prev2;\n        prev1 = prev2;\n        prev2 = current;\n    }\n    \n    return prev2;\n}",
        "complexity": {
          "time": "O(n) as we still calculate each step once.",
          "space": "O(1) as we only keep track of two variables."
        }
      }
    ],
    "completed": true,
    "answer": {
      "code": "/**\n * @param int n\n * @return int\n */\nint climbStairs(int n) {\n    // Base cases\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n    if (n == 2) return 2;\n    \n    // Use optimized space complexity approach\n    int oneStepBefore = 2;  // Ways to climb n-1 stairs\n    int twoStepsBefore = 1; // Ways to climb n-2 stairs\n    int allWays = 0;\n    \n    // Starting from step 3, build up the solution\n    for (int i = 3; i <= n; i++) {\n        // Ways to reach current step = ways to reach from one step before + ways to reach from two steps before\n        allWays = oneStepBefore + twoStepsBefore;\n        \n        // Update for the next iteration\n        twoStepsBefore = oneStepBefore;\n        oneStepBefore = allWays;\n    }\n    \n    return allWays;\n}",
      "explanation": "This problem is a classic example of dynamic programming and follows the Fibonacci sequence pattern. The key insight is that to reach step n, you can either take a single step from step n-1 or take a double step from step n-2.\n\nThus, the total number of ways to reach step n is the sum of the ways to reach step n-1 and the ways to reach step n-2.\n\nI implemented the solution using an optimized approach that uses constant space. Instead of storing all intermediate results in an array, we only need to keep track of the previous two values at any point.\n\nThe algorithm works as follows:\n1. Handle the base cases (n â¤ 2)\n2. Initialize variables to track ways to reach one and two steps before the current step\n3. Iterate from step 3 to n, calculating the number of ways at each step\n4. For each step, the number of ways equals the sum of ways for the previous two steps\n\nTime complexity: O(n) as we need to calculate the result for each step from 3 to n\nSpace complexity: O(1) as we only use three variables regardless of input size"
    }
  },
  {
    "id": "10",
    "title": "Same Tree",
    "difficulty": "Easy",
    "topics": ["Tree", "Depth-First Search", "Breadth-First Search", "Binary Tree"],
    "shortDescription": "Check if two binary trees are identical.",
    "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
    "examples": [
      {
        "input": "p = [1,2,3], q = [1,2,3]",
        "output": "true"
      },
      {
        "input": "p = [1,2], q = [1,null,2]",
        "output": "false"
      }
    ],
    "approaches": [
      {
        "name": "Recursive",
        "description": "Compare the nodes recursively, checking values and structure.",
        "solution": "bool isSameTree(TreeNode* p, TreeNode* q) {\n    // If both trees are empty\n    if (p == nullptr && q == nullptr) return true;\n    \n    // If one tree is empty but the other is not\n    if (p == nullptr || q == nullptr) return false;\n    \n    // Check current nodes and recursively check subtrees\n    return p->val == q->val && \n           isSameTree(p->left, q->left) && \n           isSameTree(p->right, q->right);\n}",
        "complexity": {
          "time": "O(n) where n is the number of nodes in the tree.",
          "space": "O(h) where h is the height of the tree for the recursion stack."
        }
      },
      {
        "name": "Iterative (BFS)",
        "description": "Use a queue to perform level-order traversal and compare nodes at each step.",
        "solution": "bool isSameTree(TreeNode* p, TreeNode* q) {\n    queue<pair<TreeNode*, TreeNode*>> queue;\n    queue.push({p, q});\n    \n    while (!queue.empty()) {\n        auto [node1, node2] = queue.front();\n        queue.pop();\n        \n        // If both null, continue to next pair\n        if (!node1 && !node2) continue;\n        \n        // If one is null or values are different\n        if (!node1 || !node2 || node1->val != node2->val) {\n            return false;\n        }\n        \n        // Push children pairs to queue\n        queue.push({node1->left, node2->left});\n        queue.push({node1->right, node2->right});\n    }\n    \n    return true;\n}",
        "complexity": {
          "time": "O(n) where n is the number of nodes in the tree.",
          "space": "O(n) in worst case for the queue."
        }
      }
    ],
    "completed": false,
    "answer": {
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n/**\n * @param TreeNode* p\n * @param TreeNode* q\n * @return bool\n */\nbool isSameTree(TreeNode* p, TreeNode* q) {\n    // Base case 1: both trees are empty\n    if (p == nullptr && q == nullptr) {\n        return true;\n    }\n    \n    // Base case 2: one tree is empty but the other is not\n    if (p == nullptr || q == nullptr) {\n        return false;\n    }\n    \n    // Check if current nodes have the same value\n    if (p->val != q->val) {\n        return false;\n    }\n    \n    // Recursively check both left and right subtrees\n    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n}",
      "explanation": "I chose the recursive approach for this problem because it elegantly captures the definition of two trees being the same: they must have identical structure and node values.\n\nThe algorithm checks three conditions:\n\n1. If both trees are null, they're the same (empty trees are identical)\n2. If one tree is null but the other isn't, they can't be the same\n3. If the current nodes have different values, the trees aren't the same\n\nIf all these checks pass, we recursively verify that both the left subtrees are identical and the right subtrees are identical.\n\nThe time complexity is O(n) where n is the number of nodes in the smaller tree, as we need to check each node at most once. The space complexity is O(h) where h is the height of the tree, due to the recursive call stack. In the worst case of a skewed tree, this could be O(n), but for a balanced tree it would be O(log n)."
    }
  },
  {
    "id": "11",
    "title": "Symmetric Tree",
    "difficulty": "Easy",
    "topics": ["Tree", "Depth-First Search", "Breadth-First Search", "Binary Tree"],
    "shortDescription": "Check if a binary tree is a mirror of itself.",
    "description": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).",
    "examples": [
      {
        "input": "root = [1,2,2,3,4,4,3]",
        "output": "true"
      },
      {
        "input": "root = [1,2,2,null,3,null,3]",
        "output": "false"
      }
    ],
    "approaches": [
      {
        "name": "Recursive",
        "description": "Compare the left subtree with the right subtree in a mirrored fashion.",
        "solution": "bool isSymmetric(TreeNode* root) {\n    if (!root) return true;\n    \n    // Helper function to check if two subtrees are mirrors\n    function<bool(TreeNode*, TreeNode*)> isMirror = [&](TreeNode* left, TreeNode* right) -> bool {\n        // If both null, they are mirrors\n        if (!left && !right) return true;\n        \n        // If one is null or values different, not mirrors\n        if (!left || !right || left->val != right->val) {\n            return false;\n        }\n        \n        // Check outer and inner pairs\n        return isMirror(left->left, right->right) && \n               isMirror(left->right, right->left);\n    };\n    \n    return isMirror(root->left, root->right);\n}",
        "complexity": {
          "time": "O(n) where n is the number of nodes in the tree.",
          "space": "O(h) where h is the height of the tree for recursion stack."
        }
      },
      {
        "name": "Iterative",
        "description": "Use a queue to compare mirrored pairs of nodes level by level.",
        "solution": "bool isSymmetric(TreeNode* root) {\n    if (!root) return true;\n    \n    queue<TreeNode*> q;\n    q.push(root->left);\n    q.push(root->right);\n    \n    while (!q.empty()) {\n        TreeNode* left = q.front();\n        q.pop();\n        TreeNode* right = q.front();\n        q.pop();\n        \n        // If both null, continue\n        if (!left && !right) continue;\n        \n        // If one is null or values different\n        if (!left || !right || left->val != right->val) {\n            return false;\n        }\n        \n        // Add mirrored pairs to queue\n        q.push(left->left);\n        q.push(right->right);\n        q.push(left->right);\n        q.push(right->left);\n    }\n    \n    return true;\n}",
        "complexity": {
          "time": "O(n) where n is the number of nodes in the tree.",
          "space": "O(n) in worst case for the queue."
        }
      }
    ],
    "completed": false,
    "answer": {
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n/**\n * @param TreeNode* root\n * @return bool\n */\nbool isSymmetric(TreeNode* root) {\n    // Empty tree is symmetric\n    if (!root) return true;\n    \n    // Helper function to check if two subtrees are mirrors of each other\n    function<bool(TreeNode*, TreeNode*)> isMirror = [](TreeNode* left, TreeNode* right) -> bool {\n        // If both subtrees are empty, they're symmetric\n        if (!left && !right) return true;\n        \n        // If only one subtree is empty, they're not symmetric\n        if (!left || !right) return false;\n        \n        // Check if current nodes have same value and their subtrees are mirrors\n        return (left->val == right->val) && \n               isMirror(left->left, right->right) && \n               isMirror(left->right, right->left);\n    };\n    \n    // Check if the left and right subtrees of the root are mirrors\n    return isMirror(root->left, root->right);\n}",
      "explanation": "For this problem, I implemented a recursive solution that checks whether a tree is symmetric around its center. A tree is symmetric if the left subtree is a mirror reflection of the right subtree.\n\nThe algorithm uses a helper function `isMirror` that takes two subtrees and checks if they are mirror images of each other. Two trees are mirrors if:\n\n1. Their root values are the same\n2. The left subtree of the first tree is a mirror of the right subtree of the second tree\n3. The right subtree of the first tree is a mirror of the left subtree of the second tree\n\nI start by comparing the left and right subtrees of the root. The base cases handle empty trees: two empty trees are symmetric, and if only one tree is empty, they can't be symmetric.\n\nThe time complexity is O(n) where n is the number of nodes in the tree, as we need to visit each node once. The space complexity is O(h) where h is the height of the tree due to the recursion stack. For a balanced tree, this would be O(log n), and for a skewed tree, it could be O(n)."
    }
  },
  {
    "id": "12",
    "title": "Maximum Depth of Binary Tree",
    "difficulty": "Easy",
    "topics": ["Tree", "Depth-First Search", "Breadth-First Search", "Binary Tree"],
    "shortDescription": "Find the maximum depth (height) of a binary tree.",
    "description": "Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "3"
      }
    ],
    "approaches": [
      {
        "name": "Recursive DFS",
        "description": "Recursively calculate the maximum depth by finding the maximum depth of the left and right subtrees and adding 1.",
        "solution": "int maxDepth(TreeNode* root) {\n    if (!root) return 0;\n    \n    int leftDepth = maxDepth(root->left);\n    int rightDepth = maxDepth(root->right);\n    \n    return max(leftDepth, rightDepth) + 1;\n}",
        "complexity": {
          "time": "O(n) where n is the number of nodes in the tree.",
          "space": "O(h) where h is the height of the tree for the recursion stack."
        }
      },
      {
        "name": "Iterative BFS",
        "description": "Use level-order traversal to count the number of levels in the tree.",
        "solution": "int maxDepth(TreeNode* root) {\n    if (!root) return 0;\n    \n    queue<TreeNode*> q;\n    q.push(root);\n    int depth = 0;\n    \n    while (!q.empty()) {\n        int levelSize = q.size();\n        depth++;\n        \n        for (int i = 0; i < levelSize; i++) {\n            TreeNode* node = q.front();\n            q.pop();\n            \n            if (node->left) q.push(node->left);\n            if (node->right) q.push(node->right);\n        }\n    }\n    \n    return depth;\n}",
        "complexity": {
          "time": "O(n) where n is the number of nodes in the tree.",
          "space": "O(n) in worst case for the queue."
        }
      }
    ],
    "completed": false,
    "answer": {
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n/**\n * @param TreeNode* root\n * @return int\n */\nint maxDepth(TreeNode* root) {\n    // Base case: empty tree has depth 0\n    if (root == nullptr) return 0;\n    \n    // Recursively find the depth of left and right subtrees\n    int leftDepth = maxDepth(root->left);\n    int rightDepth = maxDepth(root->right);\n    \n    // The depth of the tree is the maximum of the depths of\n    // the left and right subtrees, plus 1 for the current node\n    return max(leftDepth, rightDepth) + 1;\n}",
      "explanation": "I chose the recursive depth-first search (DFS) approach for finding the maximum depth of a binary tree. This solution elegantly captures the definition of tree depth.\n\nThe algorithm works as follows:\n\n1. If the tree is empty (null), its depth is 0\n2. Otherwise, calculate the maximum depth of the left subtree\n3. Calculate the maximum depth of the right subtree\n4. Return the maximum of these two depths plus 1 (to account for the current level)\n\nThe recursive solution naturally traverses the tree in a depth-first manner, exploring each path to its leaves before backtracking.\n\nTime complexity: O(n) where n is the number of nodes in the tree, as we visit each node exactly once\nSpace complexity: O(h) where h is the height of the tree, for the recursion stack. In the worst case of a skewed tree, this could be O(n), but for a balanced tree, it would be O(log n)"
    }
  },
  {
    "id": "13",
    "title": "Convert Sorted Array to Binary Search Tree",
    "difficulty": "Easy",
    "topics": ["Array", "Divide and Conquer", "Tree", "Binary Search Tree", "Binary Tree"],
    "shortDescription": "Convert a sorted array to a height-balanced BST.",
    "description": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree. A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.",
    "examples": [
      {
        "input": "nums = [-10,-3,0,5,9]",
        "output": "[0,-3,9,-10,null,5]",
        "explanation": "One valid answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST."
      }
    ],
    "approaches": [
      {
        "name": "Recursive (Divide and Conquer)",
        "description": "Use the middle element as the root and recursively build the left and right subtrees.",
        "solution": "TreeNode* sortedArrayToBST(vector<int>& nums) {\n    return buildBST(nums, 0, nums.size() - 1);\n}\n\nTreeNode* buildBST(vector<int>& nums, int left, int right) {\n    if (left > right) return nullptr;\n    \n    // Find the middle element\n    int mid = left + (right - left) / 2;\n    \n    // Create the root node with the middle element\n    TreeNode* root = new TreeNode(nums[mid]);\n    \n    // Recursively build left and right subtrees\n    root->left = buildBST(nums, left, mid - 1);\n    root->right = buildBST(nums, mid + 1, right);\n    \n    return root;\n}",
        "complexity": {
          "time": "O(n) where n is the length of the array.",
          "space": "O(log n) for the recursion stack."
        }
      },
      {
        "name": "Iterative",
        "description": "Use a stack to simulate the recursion, tracking the range of array indices for each node.",
        "solution": "TreeNode* sortedArrayToBST(vector<int>& nums) {\n    if (nums.empty()) return nullptr;\n    \n    // Use a custom struct to track the state\n    struct Element {\n        int start, end;\n        TreeNode* node;\n        TreeNode** insert_position;\n    };\n    \n    stack<Element> st;\n    TreeNode* root = nullptr;\n    \n    // Initialize with the entire array range\n    st.push({0, (int)nums.size() - 1, nullptr, &root});\n    \n    while (!st.empty()) {\n        Element cur = st.top();\n        st.pop();\n        \n        int mid = cur.start + (cur.end - cur.start) / 2;\n        TreeNode* node = new TreeNode(nums[mid]);\n        \n        // Link this node to its parent\n        *cur.insert_position = node;\n        \n        // Process right subtree (will be processed after left)\n        if (mid + 1 <= cur.end) {\n            st.push({mid + 1, cur.end, nullptr, &(node->right)});\n        }\n        \n        // Process left subtree\n        if (cur.start <= mid - 1) {\n            st.push({cur.start, mid - 1, nullptr, &(node->left)});\n        }\n    }\n    \n    return root;\n}",
        "complexity": {
          "time": "O(n) where n is the length of the array.",
          "space": "O(log n) for the stack."
        }
      }
    ],
    "completed": false,
    "answer": {
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n/**\n * @param vector<int>& nums\n * @return TreeNode*\n */\nTreeNode* sortedArrayToBST(vector<int>& nums) {\n    // Helper function to build a BST from a subarray\n    function<TreeNode*(int, int)> buildBST = [&](int left, int right) -> TreeNode* {\n        // Base case: if the subarray is empty\n        if (left > right) return nullptr;\n        \n        // Find the middle element to make it the root\n        int mid = left + (right - left) / 2;\n        \n        // Create a new tree node with the middle element\n        TreeNode* root = new TreeNode(nums[mid]);\n        \n        // Recursively build the left subtree with elements before mid\n        root->left = buildBST(left, mid - 1);\n        \n        // Recursively build the right subtree with elements after mid\n        root->right = buildBST(mid + 1, right);\n        \n        return root;\n    };\n    \n    // Start building the BST with the entire array\n    return buildBST(0, nums.size() - 1);\n}",
      "explanation": "I approached this problem using the recursive divide-and-conquer strategy, which is ideal for constructing a height-balanced binary search tree from a sorted array.\n\nThe key insight is that to create a height-balanced BST, we should choose the middle element of the array as the root. This ensures that the left and right subtrees have approximately the same number of nodes.\n\nThe algorithm works as follows:\n\n1. Find the middle element of the array and make it the root\n2. Recursively build the left subtree using the elements to the left of the middle\n3. Recursively build the right subtree using the elements to the right of the middle\n\nRather than repeatedly slicing the array, which would add extra time complexity, I used a helper function that tracks the current subarray bounds with indices. This makes the solution more efficient.\n\nTime complexity: O(n) where n is the number of elements in the array, as we need to process each element exactly once\nSpace complexity: O(log n) for the recursion stack in a balanced tree, as the maximum depth of recursion is log n"
    }
  },
  {
    "id": "14",
    "title": "Balanced Binary Tree",
    "difficulty": "Easy",
    "topics": ["Tree", "Depth-First Search", "Binary Tree"],
    "shortDescription": "Determine if a binary tree is height-balanced.",
    "description": "Given a binary tree, determine if it is height-balanced. A height-balanced binary tree is defined as a binary tree in which the left and right subtrees of every node differ in height by no more than 1.",
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "true"
      },
      {
        "input": "root = [1,2,2,3,3,null,null,4,4]",
        "output": "false"
      }
    ],
    "approaches": [
      {
        "name": "Top-Down Recursive (Naive)",
        "description": "For each node, check if its subtrees are balanced and their heights differ by no more than 1.",
        "solution": "bool isBalanced(TreeNode* root) {\n    // Get height of a node\n    function<int(TreeNode*)> height = [&](TreeNode* node) -> int {\n        if (!node) return 0;\n        return max(height(node->left), height(node->right)) + 1;\n    };\n    \n    // Check if tree is balanced\n    function<bool(TreeNode*)> checkBalance = [&](TreeNode* node) -> bool {\n        if (!node) return true;\n        \n        int leftHeight = height(node->left);\n        int rightHeight = height(node->right);\n        \n        return abs(leftHeight - rightHeight) <= 1 && \n               checkBalance(node->left) && \n               checkBalance(node->right);\n    };\n    \n    return checkBalance(root);\n}",
        "complexity": {
          "time": "O(nÂ²) in worst case as we might recalculate heights of same nodes multiple times.",
          "space": "O(h) for recursion stack where h is the height of the tree."
        }
      },
      {
        "name": "Bottom-Up Recursive (Optimized)",
        "description": "Calculate the height as we check for balance, terminating early if unbalanced.",
        "solution": "bool isBalanced(TreeNode* root) {\n    // Helper function that returns height if balanced, -1 if not balanced\n    function<int(TreeNode*)> checkHeight = [&](TreeNode* node) -> int {\n        if (!node) return 0;\n        \n        int leftHeight = checkHeight(node->left);\n        // If left subtree is unbalanced, propagate the result\n        if (leftHeight == -1) return -1;\n        \n        int rightHeight = checkHeight(node->right);\n        // If right subtree is unbalanced, propagate the result\n        if (rightHeight == -1) return -1;\n        \n        // Check if current node is balanced\n        if (abs(leftHeight - rightHeight) > 1) {\n            return -1;  // Current node is unbalanced\n        }\n        \n        // Return height of current node\n        return max(leftHeight, rightHeight) + 1;\n    };\n    \n    return checkHeight(root) != -1;\n}",
        "complexity": {
          "time": "O(n) as we only visit each node once.",
          "space": "O(h) for the recursion stack where h is the height of the tree."
        }
      }
    ],
    "completed": false,
    "answer": {
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n/**\n * @param TreeNode* root\n * @return bool\n */\nbool isBalanced(TreeNode* root) {\n    // Helper function that returns the height of a subtree if it's balanced,\n    // or -1 if it's not balanced\n    function<int(TreeNode*)> getHeight = [&](TreeNode* node) -> int {\n        // Base case: null node has height 0\n        if (node == nullptr) return 0;\n        \n        // Check the height of left subtree\n        int leftHeight = getHeight(node->left);\n        if (leftHeight == -1) return -1; // Left subtree is not balanced\n        \n        // Check the height of right subtree\n        int rightHeight = getHeight(node->right);\n        if (rightHeight == -1) return -1; // Right subtree is not balanced\n        \n        // Check if current node is balanced\n        if (abs(leftHeight - rightHeight) > 1) return -1;\n        \n        // Return the height of current subtree\n        return max(leftHeight, rightHeight) + 1;\n    };\n    \n    // A tree is balanced if getHeight doesn't return -1\n    return getHeight(root) != -1;\n}",
      "explanation": "I implemented the optimized bottom-up recursive approach for this problem. This approach is more efficient than the naive top-down approach because it avoids recalculating heights of the same nodes multiple times.\n\nThe algorithm works by using a helper function `getHeight` that:\n1. Returns the height of a subtree if it's balanced\n2. Returns -1 if the subtree is not balanced\n\nAs we traverse the tree from bottom to top, we check three conditions at each node:\n1. If the left subtree is not balanced, the entire tree is not balanced\n2. If the right subtree is not balanced, the entire tree is not balanced\n3. If the difference between the heights of left and right subtrees exceeds 1, the tree is not balanced\n\nIf none of these conditions are met, we calculate the height of the current subtree and return it.\n\nThis approach has a time complexity of O(n) where n is the number of nodes in the tree, as we visit each node exactly once. The space complexity is O(h) where h is the height of the tree, due to the recursion stack. In the worst case of a skewed tree, this could be O(n), but for a balanced tree, it would be O(log n)."
    }
  }
]

